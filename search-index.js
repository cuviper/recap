var N=null,E="",T="t",U="u",searchIndex={};
var R=["result","error","Shows the original regular expression.","formatter","regex","option","captures","splitn","usize","match","capturelocations"];

searchIndex["recap"]={"doc":"Recap deserializes structures from regex named capture…","i":[[3,"Regex","recap","A compiled regular expression for matching Unicode strings.",N,N],[5,"from_captures",E,"Deserialize a type from named regex capture groups",N,[[[R[4]],["str"]],[[R[0],[R[1]]],[R[1]]]]],[6,"Error",E,"A type which encapsulates recap errors",N,N],[11,"to_string",E,E,0,[[["self"]],["string"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,"into",E,E,0,[[],[U]]],[11,"to_owned",E,E,0,[[["self"]],[T]]],[11,"clone_into",E,E,0,[[[T],["self"]]]],[11,"try_from",E,E,0,[[[U]],[R[0]]]],[11,"try_into",E,E,0,[[],[R[0]]]],[11,"borrow_mut",E,E,0,[[["self"]],[T]]],[11,"borrow",E,E,0,[[["self"]],[T]]],[11,"type_id",E,E,0,[[["self"]],["typeid"]]],[11,"fmt",E,R[2],0,[[["self"],[R[3]]],[[R[1]],[R[0],[R[1]]]]]],[11,"fmt",E,R[2],0,[[["self"],[R[3]]],[[R[1]],[R[0],[R[1]]]]]],[11,"from_str",E,"Attempts to parse a string into a regular expression",0,[[["str"]],[[R[1]],[R[0],[R[4],R[1]]],[R[4]]]]],[11,"clone",E,E,0,[[["self"]],[R[4]]]],[11,"new",E,"Compiles a regular expression. Once compiled, it can be…",0,[[["str"]],[[R[1]],[R[0],[R[4],R[1]]],[R[4]]]]],[11,"is_match",E,"Returns true if and only if the regex matches the string…",0,[[["self"],["str"]],["bool"]]],[11,"find",E,"Returns the start and end byte range of the leftmost-first…",0,[[["str"],["self"]],[[R[9]],[R[5],[R[9]]]]]],[11,"find_iter",E,"Returns an iterator for each successive non-overlapping…",0,[[["self"],["str"]],["matches"]]],[11,R[6],E,"Returns the capture groups corresponding to the…",0,[[["str"],["self"]],[[R[5],[R[6]]],[R[6]]]]],[11,"captures_iter",E,"Returns an iterator over all the non-overlapping capture…",0,[[["self"],["str"]],["capturematches"]]],[11,"split",E,"Returns an iterator of substrings of `text` delimited by a…",0,[[["self"],["str"]],["split"]]],[11,R[7],E,"Returns an iterator of at most `limit` substrings of…",0,[[["self"],["str"],[R[8]]],[R[7]]]],[11,"replace",E,"Replaces the leftmost-first match with the replacement…",0,[[["str"],["self"],["r"]],[["cow",["str"]],["str"]]]],[11,"replace_all",E,"Replaces all non-overlapping matches in `text` with the…",0,[[["str"],["self"],["r"]],[["cow",["str"]],["str"]]]],[11,"replacen",E,"Replaces at most `limit` non-overlapping matches in `text`…",0,[[[R[8]],["str"],["self"],["r"]],[["cow",["str"]],["str"]]]],[11,"shortest_match",E,"Returns the end location of a match in the text given.",0,[[["self"],["str"]],[[R[8]],[R[5],[R[8]]]]]],[11,"shortest_match_at",E,"Returns the same as shortest_match, but starts the search…",0,[[["self"],[R[8]],["str"]],[[R[8]],[R[5],[R[8]]]]]],[11,"is_match_at",E,"Returns the same as is_match, but starts the search at the…",0,[[["self"],[R[8]],["str"]],["bool"]]],[11,"find_at",E,"Returns the same as find, but starts the search at the…",0,[[["str"],["self"],[R[8]]],[[R[9]],[R[5],[R[9]]]]]],[11,"captures_read",E,"This is like `captures`, but uses `CaptureLocations`…",0,[[["str"],["self"],[R[10]]],[[R[9]],[R[5],[R[9]]]]]],[11,"captures_read_at",E,"Returns the same as captures, but starts the search at the…",0,[[[R[8]],["str"],["self"],[R[10]]],[[R[9]],[R[5],[R[9]]]]]],[11,"as_str",E,"Returns the original string of this regex.",0,[[["self"]],["str"]]],[11,"capture_names",E,"Returns an iterator over the capture names.",0,[[["self"]],["capturenames"]]],[11,"captures_len",E,"Returns the number of captures.",0,[[["self"]],[R[8]]]],[11,"capture_locations",E,"Returns an empty set of capture locations that can be…",0,[[["self"]],[R[10]]]]],"p":[[3,"Regex"]]};
searchIndex["recap_derive"]={"doc":E,"i":[[24,"Recap","recap_derive",E,N,N]],"p":[]};
initSearch(searchIndex);addSearchOptions(searchIndex);